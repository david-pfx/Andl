using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Andl.Runtime {
  ///==========================================================================
  /// <summary>
  /// Templater specialised for generating Thrift IDL
  /// </summary>
  public class ThriftTemplater : Templater {

    readonly Dictionary<string, string> _templatedict = new Dictionary<string, string> {
      { "Heading",    "// <basename>.thrift\n" +
                      "// Thrift IDL file generated by Andl -- do not edit\n\n" +
                      "namespace * <basename>\n\n" +
                      "typedef string text\n" +
                      "typedef double number\n" +
                      "typedef i64 time\n\n" },
      { "Struct",     "struct <name> {\n<fields>}\n" },
      { "Field",      "<indent><id>: <type> <name>;\n" },
      { "Service",    "service <basename>Service {\n<entries>}\n" },
      { "Entry",      "<indent><type> <name>(\n<fields><indent>);\n" },
    };

    public ThriftTemplater() {
      _templatedicts.Insert(0, _templatedict);
    }

  }

  ///==========================================================================
  /// <summary>
  /// Implement generation of Thrift IDL file from catalog entries
  /// </summary>
  public class ThriftGen {

    public Templater Templater { get { return _templater; } set { _templater = value; } }
    Templater _templater;

    // write an entire Thrift IDL to the test writer
    public static void Process(TextWriter tw, string basename, DataType[] types, ExpressionBlock[] exprs) {
      var gen = new ThriftGen() { Templater = new ThriftTemplater() };
      tw.Write(gen.Heading(basename));
      var names = new HashSet<string>();
      foreach (var t in types.OrderBy(d => d.GetNiceName)) {
        if (!names.Contains(t.GetNiceName))
          tw.Write(gen.Struct(t.GetNiceName, t.Heading.Columns));
        names.Add(t.GetNiceName);
      }
      tw.Write(gen.Service(basename, exprs.OrderBy(e => e.Name).ToArray()));
    }

    public string Heading(string basename) {
      var dict = new Dictionary<string, SubstituteDelegate> {
        { "basename", (x) => basename },
      };
      return _templater.Process("Heading", dict);
    }

    public string Struct(string name, DataColumn[] columns) {
      var dict = new Dictionary<string, SubstituteDelegate> {
        { "name", (x) => name },
        { "fields", (x) => Fields(columns, "  ") },
        //{ "fields", (x) => Field(x, columns[x].DataType.GenCleanName, columns[x].Name) },
      };
      return _templater.Process("Struct", dict);
    }

    public string Fields(DataColumn[] columns, string indent) {
      var dict = new Dictionary<string, SubstituteDelegate> {
        { "id", (x) => (x+1).ToString() },
        { "type", (x) => TypeName(columns[x].DataType) },
        { "name", (x) => columns[x].Name },
        { "indent", (x) => indent },
      };
      return _templater.Process("Field", dict, columns.Length, "");
    }

    public string Service(string basename, ExpressionBlock[] exprs) {
      var dict = new Dictionary<string, SubstituteDelegate> {
        { "basename", (x) => basename },
        { "entries", (x) => Entries(exprs, "  ") },
      };
      return _templater.Process("Service", dict);
    }

    public string Entries(ExpressionBlock[] exprs, string indent) {
      var dict = new Dictionary<string, SubstituteDelegate> {
        { "type", (x) => TypeName(exprs[x].DataType) },
        { "name", (x) => exprs[x].Name },
        { "fields", (x) => Fields(exprs[x].Lookup.Columns, indent + "  ") },
        { "indent", (x) => indent },
      };
      return _templater.Process("Entry", dict, exprs.Length, "");
    }

    string TypeName(DataType datatype) {
      var dtr = datatype as DataTypeRelation;
      return (dtr == null) ? datatype.GetNiceName
        : "list<" + datatype.GetNiceName + ">";
    }

  }

}
